#ifndef GREENLET_EXCEPTIONS_HPP
#define GREENLET_EXCEPTIONS_HPP

#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stdexcept>
#include <string>

#ifdef __clang__
#    pragma clang diagnostic push
#    pragma clang diagnostic ignored "-Wunused-function"
#endif

namespace greenlet {

    class PyErrOccurred : public std::runtime_error
    {
    public:

        static const PyErrOccurred
        from_current()
        {
            assert(PyErr_Occurred());
#ifndef NDEBUG

            PyObject* typ;
            PyObject* val;
            PyObject* tb;

            PyErr_Fetch(&typ, &val, &tb);
            PyObject* typs = PyObject_Str(typ);
            PyObject* vals = PyObject_Str(val ? val : typ);
            const char* typ_msg = PyUnicode_AsUTF8(typs);
            const char* val_msg = PyUnicode_AsUTF8(vals);
            PyErr_Restore(typ, val, tb);

            std::string msg(typ_msg);
            msg += ": ";
            msg += val_msg;
            PyErrOccurred ex(msg);
            Py_XDECREF(typs);
            Py_XDECREF(vals);

            return ex;
#else
            return PyErrOccurred();
#endif
        }

        PyErrOccurred() : std::runtime_error("")
        {
            assert(PyErr_Occurred());
        }

        PyErrOccurred(const std::string& msg) : std::runtime_error(msg)
        {
            assert(PyErr_Occurred());
        }

        PyErrOccurred(PyObject* exc_kind, const char* const msg)
            : std::runtime_error(msg)
        {
            PyErr_SetString(exc_kind, msg);
        }

        PyErrOccurred(PyObject* exc_kind, const std::string msg)
            : std::runtime_error(msg)
        {

            PyErr_SetString(exc_kind, msg.c_str());
        }

        PyErrOccurred(PyObject* exc_kind,
                      const std::string msg, 

                      PyObject* borrowed_obj_one, PyObject* borrowed_obj_two)
            : std::runtime_error(msg)
        {

            PyErr_Format(exc_kind,
                         msg.c_str(),
                         borrowed_obj_one, borrowed_obj_two);
        }
    };

    class TypeError : public PyErrOccurred
    {
    public:
        TypeError(const char* const what)
            : PyErrOccurred(PyExc_TypeError, what)
        {
        }
        TypeError(const std::string what)
            : PyErrOccurred(PyExc_TypeError, what)
        {
        }
    };

    class ValueError : public PyErrOccurred
    {
    public:
        ValueError(const char* const what)
            : PyErrOccurred(PyExc_ValueError, what)
        {
        }
    };

    class AttributeError : public PyErrOccurred
    {
    public:
        AttributeError(const char* const what)
            : PyErrOccurred(PyExc_AttributeError, what)
        {
        }
    };

    class PyFatalError : public std::runtime_error
    {
    public:
        PyFatalError(const char* const msg)
            : std::runtime_error(msg)
        {
            Py_FatalError(msg);
        }
    };

    static inline PyObject*
    Require(PyObject* p, const std::string& msg="")
    {
        if (!p) {
            throw PyErrOccurred(msg);
        }
        return p;
    };

    static inline void
    Require(const int retval)
    {
        if (retval < 0) {
            throw PyErrOccurred();
        }
    };


};
#ifdef __clang__
#    pragma clang diagnostic pop
#endif

#endif

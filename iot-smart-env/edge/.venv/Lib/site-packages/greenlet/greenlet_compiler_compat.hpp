#ifndef GREENLET_COMPILER_COMPAT_HPP
#define GREENLET_COMPILER_COMPAT_HPP

#include <cstdint>

#    define G_NO_COPIES_OF_CLS(Cls) private:     \
    Cls(const Cls& other) = delete; \
    Cls& operator=(const Cls& other) = delete

#    define G_NO_ASSIGNMENT_OF_CLS(Cls) private:  \
    Cls& operator=(const Cls& other) = delete

#    define G_NO_COPY_CONSTRUCTOR_OF_CLS(Cls) private: \
    Cls(const Cls& other) = delete;

#if defined(__GNUC__) || defined(__clang__)
#    define GREENLET_NOINLINE(name) __attribute__((noinline)) name
#    define GREENLET_NOINLINE_P(rtype, name) rtype __attribute__((noinline)) name
#    define UNUSED(x) UNUSED_ ## x __attribute__((__unused__))
#elif defined(_MSC_VER)
#    define GREENLET_NOINLINE(name) __declspec(noinline) name
#    define GREENLET_NOINLINE_P(rtype, name) __declspec(noinline) rtype name
#    define UNUSED(x) UNUSED_ ## x
#endif

#if defined(_MSC_VER)
#    define G_NOEXCEPT_WIN32 noexcept
#else
#    define G_NOEXCEPT_WIN32
#endif

#if defined(__GNUC__) && defined(__POWERPC__) && defined(__APPLE__)
// 32-bit PPC/MacOSX. Only known to be tested on unreleased versions
// of macOS 10.6 using a macports build gcc 14. It appears that
// running C++ destructors of thread-local variables is broken.

// See https://github.com/python-greenlet/greenlet/pull/419
#     define GREENLET_BROKEN_THREAD_LOCAL_CLEANUP_JUST_LEAK 1
#else
#     define GREENLET_BROKEN_THREAD_LOCAL_CLEANUP_JUST_LEAK 0
#endif


#endif
